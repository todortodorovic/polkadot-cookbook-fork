name: Create Zero to Hero Release
description: "Test Zero to Hero code, generate Zero to Hero scripts, and publish a release"

run-name: "Zero to Hero"

env:
  PARACHAIN_REPO: "https://github.com/polkadot-developers/polkadot-docs-tests/"
  PARACHAIN_BRANCH: ${{ github.ref_name }}
  PARA_ID: "1000"
  RELAY_CHAIN: "paseo"

on:
  workflow_dispatch:
    inputs:
      create_release:
        description: 'Create a release after generating scripts'
        required: false
        default: 'false'
        type: boolean
      force_generation:
        description: 'Force script generation even if no version changes detected'
        required: false
        default: 'false'
        type: boolean
  push:
    branches: [ master, dev ]
    paths:
      - '.github/versions.yml'
  pull_request:
    branches: [ master, dev ]
    paths:
      - '.github/versions.yml'

jobs:
  # Check if zero_to_hero versions have changed
  check-version-changes:
    name: Check Version Changes
    runs-on: ubuntu-latest
    outputs:
      has-changes: ${{ steps.check-changes.outputs.has-changes }}
      changed-versions: ${{ steps.check-changes.outputs.changed-versions }}
    steps:
      - name: Checkout current commit
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Install yq for YAML parsing
        run: |
          sudo wget -qO /usr/local/bin/yq https://github.com/mikefarah/yq/releases/latest/download/yq_linux_amd64
          sudo chmod +x /usr/local/bin/yq

      - name: Check for zero_to_hero version changes
        id: check-changes
        run: |
          echo "$(date -Iseconds) ğŸ” Checking for zero_to_hero version changes..."
          
          DEPS_FILE=".github/versions.yml"
          TUTORIAL="zero_to_hero"
          HAS_CHANGES="false"
          CHANGED_VERSIONS=""
          
          # Validate that config file exists
          if [ ! -f "$DEPS_FILE" ]; then
            echo "âŒ Dependencies file not found: $DEPS_FILE"
            exit 1
          fi
          
          # Function to get version (tutorial-specific first, then global)
          get_version() {
            local dep="$1"
            local version
            
            # Try tutorial-specific version first
            version=$(yq eval ".${TUTORIAL}.${dep}" "$DEPS_FILE" 2>/dev/null)
            if [ "$version" = "null" ] || [ -z "$version" ]; then
              # Fallback to global version
              version=$(yq eval ".versions.${dep}" "$DEPS_FILE" 2>/dev/null)
            fi
            
            echo "$version"
          }
          
          # Get current versions
          CURRENT_RUST=$(get_version "rust")
          CURRENT_CHAIN_SPEC=$(get_version "chain_spec_builder") 
          CURRENT_OMNI_NODE=$(get_version "polkadot_omni_node")
          
          echo "ğŸ“‹ Current versions:"
          echo "  - rust: $CURRENT_RUST"
          echo "  - chain_spec_builder: $CURRENT_CHAIN_SPEC"
          echo "  - polkadot_omni_node: $CURRENT_OMNI_NODE"
          
          # Check for manual force generation
          if [ "${{ github.event.inputs.force_generation }}" = "true" ]; then
            echo "ğŸ”„ Force generation enabled - proceeding with script generation"
            HAS_CHANGES="true"
            CHANGED_VERSIONS="forced generation"
          # For workflow_dispatch, always proceed unless explicitly forced
          elif [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            echo "ğŸ”„ Manual trigger detected - proceeding with script generation"
            HAS_CHANGES="true"
            CHANGED_VERSIONS="manual trigger"
          else
            # For push/PR events, check what changed
            if [ "${{ github.event_name }}" = "pull_request" ]; then
              BASE_SHA="${{ github.event.pull_request.base.sha }}"
            else
              # For push events, compare with previous commit
              BASE_SHA="${{ github.event.before }}"
            fi
            
            echo "ğŸ” Comparing with base commit: $BASE_SHA"
            
            # Check if we have a valid base SHA and it exists
            if [ "$BASE_SHA" != "0000000000000000000000000000000000000000" ] && git cat-file -e "$BASE_SHA" 2>/dev/null; then
              # Get previous versions if the file existed
              if git cat-file -e "$BASE_SHA:$DEPS_FILE" 2>/dev/null; then
                echo "ğŸ“‹ Getting previous versions from $BASE_SHA..."
                
                # Create temporary file with previous versions
                git show "$BASE_SHA:$DEPS_FILE" > previous_versions.yml
                
                # Function to get version from previous file
                get_previous_version() {
                  local dep="$1"
                  local version
                  
                  # Try tutorial-specific version first
                  version=$(yq eval ".${TUTORIAL}.${dep}" previous_versions.yml 2>/dev/null)
                  if [ "$version" = "null" ] || [ -z "$version" ]; then
                    # Fallback to global version
                    version=$(yq eval ".versions.${dep}" previous_versions.yml 2>/dev/null)
                  fi
                  
                  echo "$version"
                }
                
                PREVIOUS_RUST=$(get_previous_version "rust")
                PREVIOUS_CHAIN_SPEC=$(get_previous_version "chain_spec_builder")
                PREVIOUS_OMNI_NODE=$(get_previous_version "polkadot_omni_node")
                
                echo "ğŸ“‹ Previous versions:"
                echo "  - rust: $PREVIOUS_RUST"
                echo "  - chain_spec_builder: $PREVIOUS_CHAIN_SPEC"  
                echo "  - polkadot_omni_node: $PREVIOUS_OMNI_NODE"
                
                # Compare versions
                CHANGES_FOUND=""
                
                if [ "$CURRENT_RUST" != "$PREVIOUS_RUST" ]; then
                  echo "ğŸ”„ Rust version changed: $PREVIOUS_RUST â†’ $CURRENT_RUST"
                  CHANGES_FOUND="$CHANGES_FOUND rust($PREVIOUS_RUSTâ†’$CURRENT_RUST)"
                fi
                
                if [ "$CURRENT_CHAIN_SPEC" != "$PREVIOUS_CHAIN_SPEC" ]; then
                  echo "ğŸ”„ Chain spec builder version changed: $PREVIOUS_CHAIN_SPEC â†’ $CURRENT_CHAIN_SPEC"
                  CHANGES_FOUND="$CHANGES_FOUND chain_spec_builder($PREVIOUS_CHAIN_SPECâ†’$CURRENT_CHAIN_SPEC)"
                fi
                
                if [ "$CURRENT_OMNI_NODE" != "$PREVIOUS_OMNI_NODE" ]; then
                  echo "ğŸ”„ Omni node version changed: $PREVIOUS_OMNI_NODE â†’ $CURRENT_OMNI_NODE"
                  CHANGES_FOUND="$CHANGES_FOUND polkadot_omni_node($PREVIOUS_OMNI_NODEâ†’$CURRENT_OMNI_NODE)"
                fi
                
                if [ -n "$CHANGES_FOUND" ]; then
                  HAS_CHANGES="true"
                  CHANGED_VERSIONS="$CHANGES_FOUND"
                  echo "âœ… Zero to Hero version changes detected!"
                else
                  echo "â„¹ï¸ No zero_to_hero version changes detected"
                fi
                
                # Cleanup
                rm -f previous_versions.yml
              else
                echo "ğŸ“ Previous versions.yml not found - treating as new file"
                HAS_CHANGES="true"
                CHANGED_VERSIONS="new versions file"
              fi
            else
              echo "âš ï¸ Cannot compare versions (invalid or missing base commit) - proceeding with generation"
              HAS_CHANGES="true"
              CHANGED_VERSIONS="unable to compare"
            fi
          fi
          
          echo "has-changes=$HAS_CHANGES" >> $GITHUB_OUTPUT
          echo "changed-versions=$CHANGED_VERSIONS" >> $GITHUB_OUTPUT
          
          if [ "$HAS_CHANGES" = "true" ]; then
            echo "$(date -Iseconds) âœ… Proceeding with script generation"
            echo "ğŸ“‹ Changes detected: $CHANGED_VERSIONS"
          else
            echo "$(date -Iseconds) â­ï¸ Skipping script generation (no version changes)"
          fi

  # First, run the existing parachain build workflow
  build-parachain:
    name: Build Parachain
    needs: check-version-changes
    if: needs.check-version-changes.outputs.has-changes == 'true'
    uses: ./.github/workflows/build-kitchensink-parachain.yml
    secrets: inherit

  # Generate setup scripts after successful build
  generate-scripts:
    name: Generate Scripts for Zero to Hero tutorial
    runs-on: ubuntu-latest
    needs: [check-version-changes, build-parachain]
    if: always() && needs.check-version-changes.outputs.has-changes == 'true' && needs.build-parachain.result == 'success'
    outputs:
      rust-version: ${{ steps.resolve-versions.outputs.rust-version }}
      chain-spec-builder-version: ${{ steps.resolve-versions.outputs.chain-spec-builder-version }}
      omni-node-version: ${{ steps.resolve-versions.outputs.omni-node-version }}
      scripts-committed: ${{ steps.commit-scripts.outputs.scripts-committed }}
      commit-sha: ${{ steps.commit-scripts.outputs.commit-sha }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          # Fetch full history for proper git operations
          fetch-depth: 0
          # Use a token that can push to protected branches
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Read versions from versions.yml
        id: resolve-versions
        run: |
          # Install yq for YAML parsing
          sudo wget -qO /usr/local/bin/yq https://github.com/mikefarah/yq/releases/latest/download/yq_linux_amd64
          sudo chmod +x /usr/local/bin/yq
          
          DEPS_FILE=".github/versions.yml"
          TUTORIAL="zero_to_hero"
          
          # Validate that config file exists
          if [ ! -f "$DEPS_FILE" ]; then
            echo "âŒ Dependencies file not found: $DEPS_FILE"
            exit 1
          fi
          
          # Function to get version (tutorial-specific first, then global)
          get_version() {
            local dep="$1"
            local version
            
            # Try tutorial-specific version first
            version=$(yq eval ".${TUTORIAL}.${dep}" "$DEPS_FILE" 2>/dev/null)
            if [ "$version" = "null" ] || [ -z "$version" ]; then
              # Fallback to global version
              version=$(yq eval ".versions.${dep}" "$DEPS_FILE" 2>/dev/null)
            fi
            
            echo "$version"
          }
          
          # Get versions from config file
          CHAIN_SPEC_VERSION=$(get_version "chain_spec_builder")
          OMNI_NODE_VERSION=$(get_version "polkadot_omni_node")
          RUST_VERSION=$(get_version "rust")
          
          # Validate all versions were resolved
          if [ -z "$CHAIN_SPEC_VERSION" ] || [ "$CHAIN_SPEC_VERSION" = "null" ]; then
            echo "âŒ chain-spec-builder version not resolved"
            exit 1
          fi
          
          if [ -z "$OMNI_NODE_VERSION" ] || [ "$OMNI_NODE_VERSION" = "null" ]; then
            echo "âŒ omni-node version not resolved"
            exit 1
          fi
          
          if [ -z "$RUST_VERSION" ] || [ "$RUST_VERSION" = "null" ]; then
            echo "âŒ rust version not resolved"
            exit 1
          fi
          
          echo "chain-spec-builder-version=$CHAIN_SPEC_VERSION" >> $GITHUB_OUTPUT
          echo "omni-node-version=$OMNI_NODE_VERSION" >> $GITHUB_OUTPUT
          echo "rust-version=$RUST_VERSION" >> $GITHUB_OUTPUT
          
          echo "$(date -Iseconds) ğŸ“‹ Resolved versions for scripts:"
          echo "  - chain-spec-builder: $CHAIN_SPEC_VERSION"
          echo "  - omni-node: $OMNI_NODE_VERSION" 
          echo "  - rust: $RUST_VERSION"
          echo "ğŸ”„ Triggered by: ${{ needs.check-version-changes.outputs.changed-versions }}"

      - name: Create scripts directory
        run: |
          echo "$(date -Iseconds) ğŸ“ Creating scripts directory..."
          mkdir -p scripts/zero-to-hero
          echo "âœ… Scripts directory created"

      - name: Generate Rust setup script
        run: |
          echo "$(date -Iseconds) ğŸ¦€ Generating Rust setup script..."
          cat > scripts/zero-to-hero/setup-rust.sh << 'EOF'
          #!/bin/bash
          # Rust Setup Script
          # This script sets up Rust with the required version and components
          
          set -e
          
          RUST_VERSION="${{ steps.resolve-versions.outputs.rust-version }}"
          
          echo "ğŸ¦€ Setting up Rust $RUST_VERSION..."
          echo "ğŸ“¦ Installing Rust toolchain and components..."
          
          # Set default Rust version
          rustup default $RUST_VERSION
          
          # Add WASM target for the current platform
          rustup target add wasm32-unknown-unknown --toolchain $RUST_VERSION
          
          # Add rust source for the current platform  
          rustup component add rust-src --toolchain $RUST_VERSION
          
          echo "âœ… Rust setup completed successfully!"
          echo "ğŸ“‹ Installed components:"
          echo "  - Rust toolchain: $RUST_VERSION"
          echo "  - WASM target: wasm32-unknown-unknown"
          echo "  - Rust source component"
          
          # Verify installation
          echo "ğŸ” Verifying installation..."
          rustup show
          EOF
          
          chmod +x scripts/zero-to-hero/setup-rust.sh
          echo "âœ… Rust setup script created: scripts/zero-to-hero/setup-rust.sh"

      - name: Generate chain-spec-builder setup script
        run: |
          echo "$(date -Iseconds) ğŸ”§ Generating chain-spec-builder setup script..."
          cat > scripts/zero-to-hero/install-chain-spec-builder.sh << 'EOF'
          #!/bin/bash
          # Chain Spec Builder Installation Script
          # This script installs the staging-chain-spec-builder tool
          
          set -e
          
          CHAIN_SPEC_VERSION="${{ steps.resolve-versions.outputs.chain-spec-builder-version }}"
          
          echo "ğŸ”§ Installing staging-chain-spec-builder $CHAIN_SPEC_VERSION..."
          
          # Install chain-spec-builder with locked dependencies
          cargo install --locked staging-chain-spec-builder@$CHAIN_SPEC_VERSION
          
          echo "âœ… Chain spec builder installation completed!"
          echo "ğŸ“‹ Installed version: $CHAIN_SPEC_VERSION"
          
          # Verify installation
          echo "ğŸ” Verifying installation..."
          chain-spec-builder --version
          EOF
          
          chmod +x scripts/zero-to-hero/install-chain-spec-builder.sh
          echo "âœ… Chain spec builder script created: scripts/zero-to-hero/install-chain-spec-builder.sh"

      - name: Generate omni-node setup script
        run: |
          echo "$(date -Iseconds) ğŸš€ Generating omni-node setup script..."
          cat > scripts/zero-to-hero/install-omni-node.sh << 'EOF'
          #!/bin/bash
          # Omni Node Installation Script  
          # This script installs the polkadot-omni-node
          
          set -e
          
          OMNI_NODE_VERSION="${{ steps.resolve-versions.outputs.omni-node-version }}"
          
          echo "ğŸš€ Installing polkadot-omni-node $OMNI_NODE_VERSION..."
          
          # Install omni-node with locked dependencies
          cargo install --locked polkadot-omni-node@$OMNI_NODE_VERSION
          
          echo "âœ… Omni node installation completed!"
          echo "ğŸ“‹ Installed version: $OMNI_NODE_VERSION"
          
          # Verify installation
          echo "ğŸ” Verifying installation..."
          polkadot-omni-node --version
          EOF
          
          chmod +x scripts/zero-to-hero/install-omni-node.sh  
          echo "âœ… Omni node script created: scripts/zero-to-hero/install-omni-node.sh"

      - name: Generate chain spec creation script
        run: |
          echo "$(date -Iseconds) â›“ï¸ Generating chain spec creation script..."
          cat > scripts/zero-to-hero/generate-chain-spec.sh << 'EOF'
          #!/bin/bash
          # Chain Specification Generation Script
          # This script generates a development chain specification for the parachain
          
          set -e
          
          PARA_ID="${{ env.PARA_ID }}"
          RELAY_CHAIN="${{ env.RELAY_CHAIN }}"
          RUNTIME_PATH="./target/release/wbuild/parachain-template-runtime/parachain_template_runtime.compact.compressed.wasm"
          
          echo "â›“ï¸ Generating chain specification..."
          echo "ğŸ“‹ Configuration:"
          echo "  - Para ID: $PARA_ID"
          echo "  - Relay Chain: $RELAY_CHAIN"
          echo "  - Runtime: $RUNTIME_PATH"
          
          # Check if runtime exists
          if [ ! -f "$RUNTIME_PATH" ]; then
            echo "âŒ Runtime WASM file not found: $RUNTIME_PATH"
            echo "ğŸ’¡ Make sure you have built the parachain runtime first"
            echo "ğŸ’¡ Try running: cargo build --release"
            exit 1
          fi
          
          # Generate chain specification
          chain-spec-builder create \
            -t development \
            --relay-chain $RELAY_CHAIN \
            --para-id $PARA_ID \
            --runtime $RUNTIME_PATH \
            named-preset development
          
          # Verify chain spec was created
          if [ ! -f "chain_spec.json" ]; then
            echo "âŒ Chain specification generation failed"
            exit 1
          fi
          
          echo "âœ… Chain specification generated successfully!"
          echo "ğŸ“„ Output file: chain_spec.json"
          echo "ğŸ“Š File size: $(du -h chain_spec.json | cut -f1)"
          
          # Validate JSON
          if command -v jq >/dev/null 2>&1; then
            echo "ğŸ” Validating JSON structure..."
            if jq empty chain_spec.json; then
              echo "âœ… Chain specification is valid JSON"
              
              # Extract key information
              CHAIN_NAME=$(jq -r '.name // "unknown"' chain_spec.json)
              echo "ğŸ“‹ Chain Name: $CHAIN_NAME"
            else
              echo "âš ï¸ Chain specification may have JSON formatting issues"
            fi
          fi
          EOF
          
          chmod +x scripts/zero-to-hero/generate-chain-spec.sh
          echo "âœ… Chain spec generation script created: scripts/zero-to-hero/generate-chain-spec.sh"

      - name: Generate node startup script
        run: |
          echo "$(date -Iseconds) ğŸ–¥ï¸ Generating node startup script..."
          cat > scripts/zero-to-hero/start-node.sh << 'EOF'
          #!/bin/bash
          # Parachain Node Startup Script
          # This script starts the parachain node in development mode
          
          set -e
          
          CHAIN_SPEC="./chain_spec.json"
          
          echo "ğŸ–¥ï¸ Starting parachain node..."
          echo "ğŸ“‹ Configuration:"
          echo "  - Chain spec: $CHAIN_SPEC"
          echo "  - Mode: Development"
          echo "  - RPC: All CORS enabled, unsafe methods allowed"
          
          # Check if chain spec exists
          if [ ! -f "$CHAIN_SPEC" ]; then
            echo "âŒ Chain specification not found: $CHAIN_SPEC"
            echo "ğŸ’¡ Generate it first by running: ./scripts/zero-to-hero/generate-chain-spec.sh"
            exit 1
          fi
          
          echo "ğŸš€ Starting polkadot-omni-node..."
          echo "ğŸ“¡ RPC will be available at: http://localhost:9944"
          echo "ğŸ” Press Ctrl+C to stop the node"
          echo ""
          
          # Start the node
          polkadot-omni-node \
            --chain $CHAIN_SPEC \
            --dev \
            --rpc-cors all \
            --rpc-methods unsafe
          EOF
          
          chmod +x scripts/zero-to-hero/start-node.sh
          echo "âœ… Node startup script created: scripts/zero-to-hero/start-node.sh"

      - name: Generate setup instructions
        run: |
          echo "$(date -Iseconds) ğŸ“– Generating setup instructions..."
          cat > scripts/zero-to-hero/README.md << 'EOF'
          # Parachain Development Scripts
          
          This directory contains scripts to set up and run a local parachain development environment.
          
          ## Generated Configuration
          
          These scripts were generated automatically with the following versions:
          - **Rust**: `${{ steps.resolve-versions.outputs.rust-version }}`
          - **Chain Spec Builder**: `${{ steps.resolve-versions.outputs.chain-spec-builder-version }}`
          - **Omni Node**: `${{ steps.resolve-versions.outputs.omni-node-version }}`
          - **Para ID**: `${{ env.PARA_ID }}`
          - **Relay Chain**: `${{ env.RELAY_CHAIN }}`
          
          **Version Changes**: ${{ needs.check-version-changes.outputs.changed-versions }}
          
          ## Quick Start
          
          1. **Setup Rust toolchain:**
             ```bash
             ./scripts/zero-to-hero/setup-rust.sh
             ```
          
          2. **Install chain-spec-builder:**
             ```bash
             ./scripts/zero-to-hero/install-chain-spec-builder.sh
             ```
          
          3. **Install omni-node:**
             ```bash
             ./scripts/zero-to-hero/install-omni-node.sh
             ```
          
          4. **Build your parachain runtime** (if not already done):
             ```bash
             cargo build --release
             ```
          
          5. **Generate chain specification:**
             ```bash
             ./scripts/zero-to-hero/generate-chain-spec.sh
             ```
          
          6. **Start the parachain node:**
             ```bash
             ./scripts/zero-to-hero/start-node.sh
             ```
          
          ## Script Details
          
          ### `setup-rust.sh`
          Sets up the Rust toolchain with the required version and adds WASM compilation support.
          
          ### `install-chain-spec-builder.sh`
          Installs the staging-chain-spec-builder tool for generating chain specifications.
          
          ### `install-omni-node.sh`
          Installs the polkadot-omni-node for running the parachain.
          
          ### `generate-chain-spec.sh`
          Creates a development chain specification file (`chain_spec.json`) for your parachain.
          
          ### `start-node.sh`
          Starts the parachain node in development mode with RPC endpoints enabled.
          
          ## RPC Endpoints
          
          Once the node is running, you can access:
          - **HTTP RPC**: `http://localhost:9944`
          - **WebSocket RPC**: `ws://localhost:9944`
          
          ## Repository Information
          
          - **Source**: `${{ env.PARACHAIN_REPO }}`
          - **Branch**: `${{ env.PARACHAIN_BRANCH }}`
          - **Generated**: $(date -Iseconds)
          - **Workflow**: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}
          - **Commit**: ${{ github.sha }}
          EOF
          
          echo "âœ… Setup instructions created: scripts/zero-to-hero/README.md"

      - name: Validate generated scripts
        run: |
          echo "$(date -Iseconds) ğŸ” Validating generated scripts..."
          
          # Check that all scripts exist and are executable
          SCRIPTS=(
            "setup-rust.sh"
            "install-chain-spec-builder.sh" 
            "install-omni-node.sh"
            "generate-chain-spec.sh"
            "start-node.sh"
          )
          
          for script in "${SCRIPTS[@]}"; do
            SCRIPT_PATH="scripts/zero-to-hero/$script"
            if [ -f "$SCRIPT_PATH" ] && [ -x "$SCRIPT_PATH" ]; then
              echo "âœ… $script - exists and executable"
              echo "   ğŸ“Š Size: $(du -h "$SCRIPT_PATH" | cut -f1)"
            else
              echo "âŒ $script - missing or not executable"
              exit 1
            fi
          done
          
          # Validate README exists
          if [ -f "scripts/zero-to-hero/README.md" ]; then
            echo "âœ… README.md - exists"
            echo "   ğŸ“Š Size: $(du -h scripts/zero-to-hero/README.md | cut -f1)"
          else
            echo "âŒ README.md - missing"
            exit 1
          fi
          
          echo "$(date -Iseconds) âœ… All scripts validated successfully"

      - name: Commit generated scripts to repository
        id: commit-scripts
        run: |
          echo "$(date -Iseconds) ğŸ’¾ Committing generated scripts to repository..."
          
          # Configure git with bot credentials
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          
          # Add the scripts directory
          git add scripts/zero-to-hero/
          
          # Check if there are changes to commit
          if git diff --cached --quiet; then
            echo "â„¹ï¸ No changes to commit - scripts are up to date"
            echo "scripts-committed=false" >> $GITHUB_OUTPUT
            echo "commit-sha=$(git rev-parse HEAD)" >> $GITHUB_OUTPUT
          else
            # Create a comprehensive commit message
            COMMIT_MSG="ğŸ¤– Update zero-to-hero setup scripts

          Version changes: ${{ needs.check-version-changes.outputs.changed-versions }}
          
          Updated component versions:
          - Rust: ${{ steps.resolve-versions.outputs.rust-version }}
          - Chain Spec Builder: ${{ steps.resolve-versions.outputs.chain-spec-builder-version }}
          - Omni Node: ${{ steps.resolve-versions.outputs.omni-node-version }}
          
          Scripts updated:
          - setup-rust.sh
          - install-chain-spec-builder.sh
          - install-omni-node.sh
          - generate-chain-spec.sh
          - start-node.sh
          - README.md
          
          Generated: $(date -u +'%Y-%m-%d %H:%M:%S UTC')
          Workflow: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}
          
          Co-authored-by: github-actions[bot] <github-actions[bot]@users.noreply.github.com>"
            
            # Commit the changes
            git commit -m "$COMMIT_MSG"
            
            # Get the commit SHA after committing
            COMMIT_SHA=$(git rev-parse HEAD)
            
            # Push the changes
            echo "ğŸ“¤ Pushing changes to ${{ github.ref_name }}..."
            git push origin ${{ github.ref_name }}
            
            echo "âœ… Scripts committed and pushed to repository"
            echo "ğŸ“‹ Commit: $COMMIT_SHA"
            echo "ğŸ”— View: ${{ github.server_url }}/${{ github.repository }}/commit/$COMMIT_SHA"
            
            echo "scripts-committed=true" >> $GITHUB_OUTPUT
            echo "commit-sha=$COMMIT_SHA" >> $GITHUB_OUTPUT
          fi

      - name: Upload generated scripts as artifacts
        uses: actions/upload-artifact@v4
        with:
          name: parachain-setup-scripts-${{ github.run_id }}
          path: scripts/zero-to-hero/
          retention-days: 30

      - name: Create scripts archive
        run: |
          echo "$(date -Iseconds) ğŸ“¦ Creating scripts archive..."
          tar -czf parachain-zero-to-hero-scripts.tar.gz scripts/zero-to-hero/
          echo "âœ… Archive created: parachain-zero-to-hero-scripts.tar.gz"
          echo "ğŸ“Š Archive size: $(du -h parachain-zero-to-hero-scripts.tar.gz | cut -f1)"

      - name: Upload scripts archive as artifacts
        uses: actions/upload-artifact@v4
        with:
          name: parachain-zero-to-hero-scripts-archive-${{ github.run_id }}
          path: parachain-zero-to-hero-scripts.tar.gz
          retention-days: 30

  create-release:
    name: Create Release with Scripts
    runs-on: ubuntu-latest
    needs: [check-version-changes, build-parachain, generate-scripts]
    if: |
      always() && 
      needs.check-version-changes.outputs.has-changes == 'true' && 
      needs.generate-scripts.result == 'success' &&
      needs.generate-scripts.outputs.scripts-committed == 'true' &&
      (
        (github.event_name == 'push' && (github.ref == 'refs/heads/master' || github.ref == 'refs/heads/dev')) ||
        github.event.inputs.create_release == 'true'
      )
    permissions:
      contents: write
      actions: read
      pull-requests: read
    outputs:
      release-tag: ${{ steps.create-tag.outputs.tag }}
      release-url: ${{ steps.create-release.outputs.html_url }}
    steps:
      - name: Checkout at scripts commit
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}
          ref: ${{ needs.generate-scripts.outputs.commit-sha }}

      - name: Verify scripts are present
        run: |
          echo "$(date -Iseconds) ğŸ” Verifying scripts are present..."
          
          SCRIPTS_COMMIT_SHA="${{ needs.generate-scripts.outputs.commit-sha }}"
          CURRENT_SHA=$(git rev-parse HEAD)
          
          echo "ğŸ“‹ Expected commit: $SCRIPTS_COMMIT_SHA"
          echo "ğŸ“‹ Current commit: $CURRENT_SHA"
          
          if [ "$CURRENT_SHA" != "$SCRIPTS_COMMIT_SHA" ]; then
            echo "âŒ Not at expected commit! Fetching latest..."
            git fetch origin
            git checkout $SCRIPTS_COMMIT_SHA
            CURRENT_SHA=$(git rev-parse HEAD)
            echo "ğŸ“‹ Updated to: $CURRENT_SHA"
          fi
          
          # Verify scripts directory exists
          if [ -d "scripts/zero-to-hero" ]; then
            echo "âœ… Scripts directory found"
            echo "ğŸ“‹ Scripts available:"
            ls -la scripts/zero-to-hero/
          else
            echo "âŒ Scripts directory not found at commit $CURRENT_SHA!"
            echo "ğŸ” Repository contents:"
            ls -la
            exit 1
          fi

      - name: Determine version bump
        id: version-bump
        run: |
          echo "$(date -Iseconds) ğŸ” Determining version bump..."
          
          # Get the latest tag, default to v0.0.0 if no tags exist
          LATEST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "v0.0.0")
          echo "ğŸ“‹ Latest tag: $LATEST_TAG"
          
          # Extract version components (remove 'v' prefix)
          VERSION=${LATEST_TAG#v}
          IFS='.' read -ra VERSION_PARTS <<< "$VERSION"
          MAJOR=${VERSION_PARTS[0]:-0}
          MINOR=${VERSION_PARTS[1]:-0} 
          PATCH=${VERSION_PARTS[2]:-0}
          
          echo "ğŸ“‹ Current version: $MAJOR.$MINOR.$PATCH"
          
          # Analyze commits since last tag to determine bump type
          if [ "$LATEST_TAG" = "v0.0.0" ]; then
            COMMITS_SINCE=""
          else
            COMMITS_SINCE=$(git log $LATEST_TAG..HEAD --oneline)
          fi
          
          # Determine bump type based on commit messages and branch
          BUMP_TYPE="patch"  # Default to patch
          
          # Check for breaking changes (major bump)
          if echo "$COMMITS_SINCE" | grep -i -E "(breaking|major|BREAKING CHANGE)" > /dev/null; then
            BUMP_TYPE="major"
          # Check for new features (minor bump)
          elif echo "$COMMITS_SINCE" | grep -i -E "(feat|feature|add|new)" > /dev/null; then
            BUMP_TYPE="minor"
          # Check if we're on dev branch (pre-release)
          elif [ "${{ github.ref }}" = "refs/heads/dev" ]; then
            BUMP_TYPE="prerelease"
          fi
          
          # Apply version bump
          case $BUMP_TYPE in
            major)
              MAJOR=$((MAJOR + 1))
              MINOR=0
              PATCH=0
              ;;
            minor)
              MINOR=$((MINOR + 1))
              PATCH=0
              ;;
            patch)
              PATCH=$((PATCH + 1))
              ;;
            prerelease)
              # For pre-release, increment patch and add pre-release identifier
              PATCH=$((PATCH + 1))
              PRE_RELEASE="dev.$(date +%Y%m%d%H%M%S)"
              ;;
          esac
          
          # Construct new version
          if [ "$BUMP_TYPE" = "prerelease" ]; then
            NEW_VERSION="$MAJOR.$MINOR.$PATCH-$PRE_RELEASE"
          else
            NEW_VERSION="$MAJOR.$MINOR.$PATCH"
          fi
          
          echo "bump-type=$BUMP_TYPE" >> $GITHUB_OUTPUT
          echo "new-version=$NEW_VERSION" >> $GITHUB_OUTPUT
          echo "previous-tag=$LATEST_TAG" >> $GITHUB_OUTPUT
          
          echo "$(date -Iseconds) âœ… Version bump determined:"
          echo "  - Type: $BUMP_TYPE"
          echo "  - Previous: $LATEST_TAG"
          echo "  - New: v$NEW_VERSION"

      - name: Generate changelog
        id: changelog
        run: |
          echo "$(date -Iseconds) ğŸ“ Generating changelog..."
          
          NEW_VERSION="${{ steps.version-bump.outputs.new-version }}"
          PREVIOUS_TAG="${{ steps.version-bump.outputs.previous-tag }}"
          RUST_VERSION="${{ needs.generate-scripts.outputs.rust-version }}"
          CHAIN_SPEC_VERSION="${{ needs.generate-scripts.outputs.chain-spec-builder-version }}"
          OMNI_NODE_VERSION="${{ needs.generate-scripts.outputs.omni-node-version }}"
          CHANGED_VERSIONS="${{ needs.check-version-changes.outputs.changed-versions }}"
          SCRIPTS_COMMIT_SHA="${{ needs.generate-scripts.outputs.commit-sha }}"
          
          # Create changelog file
          CHANGELOG_FILE="RELEASE_CHANGELOG.md"
          
          cat > $CHANGELOG_FILE << EOF
          # Release v$NEW_VERSION
          
          Released: $(date -u +"%Y-%m-%d %H:%M:%S UTC")
          
          ## ğŸ¯ What's New
          
          This release includes automatically generated setup scripts for local parachain development with updated component versions.
          
          ### ğŸ”„ Version Changes
          **Triggered by**: $CHANGED_VERSIONS
          
          ### ğŸ“¦ Component Versions
          - **Rust Toolchain**: \`$RUST_VERSION\`
          - **Chain Spec Builder**: \`staging-chain-spec-builder@$CHAIN_SPEC_VERSION\`
          - **Omni Node**: \`polkadot-omni-node@$OMNI_NODE_VERSION\`
          - **Para ID**: \`${{ env.PARA_ID }}\`
          - **Relay Chain**: \`${{ env.RELAY_CHAIN }}\`
          
          ### ğŸ› ï¸ Generated Scripts
          - \`setup-rust.sh\` - Complete Rust toolchain setup with WASM support
          - \`install-chain-spec-builder.sh\` - Chain specification builder installation
          - \`install-omni-node.sh\` - Polkadot omni-node installation  
          - \`generate-chain-spec.sh\` - Chain specification generation
          - \`start-node.sh\` - Parachain node startup script
          - \`README.md\` - Comprehensive setup and troubleshooting guide
          
          ### ğŸ”§ Features
          - âœ… Automated version resolution from \`versions.yml\`
          - âœ… Intelligent change detection (only runs when zero_to_hero versions change)
          - âœ… Cross-platform compatibility (detects current architecture)
          - âœ… Comprehensive error handling and validation
          - âœ… Step-by-step setup instructions
          - âœ… Ready-to-use development environment
          - âœ… Scripts automatically committed to repository
          
          ### ğŸ’¾ Repository Updates
          - Scripts automatically committed and included in this release
          - Scripts Commit: [\`${SCRIPTS_COMMIT_SHA:0:7}\`](${{ github.server_url }}/${{ github.repository }}/commit/$SCRIPTS_COMMIT_SHA)
          
          EOF
          
          # Add commit history if available
          if [ "$PREVIOUS_TAG" != "v0.0.0" ]; then
            echo "### ğŸ“‹ Changes Since $PREVIOUS_TAG" >> $CHANGELOG_FILE
            echo "" >> $CHANGELOG_FILE
            
            # Get commits since last tag, format them nicely
            git log $PREVIOUS_TAG..HEAD --oneline --no-merges | head -20 | while read commit; do
              echo "- $commit" >> $CHANGELOG_FILE
            done
            
            echo "" >> $CHANGELOG_FILE
          fi
          
          # Add technical details
          cat >> $CHANGELOG_FILE << EOF
          ### ğŸ—ï¸ Build Information
          - **Workflow**: Version Change Detection â†’ Build Parachain â†’ Generate Scripts â†’ Commit to Repo â†’ Create Release
          - **Branch**: \`${{ github.ref_name }}\`
          - **Release Commit**: \`$SCRIPTS_COMMIT_SHA\`
          - **Parachain Source**: [\`${{ env.PARACHAIN_REPO }}\`](${{ env.PARACHAIN_REPO }})
          - **Version Changes**: $CHANGED_VERSIONS
          
          ### ğŸ“¥ Quick Start
          
          #### Option 1: Use scripts from repository (Recommended)
          1. Clone or update your repository to get the latest scripts:
             \`\`\`bash
             git clone ${{ github.server_url }}/${{ github.repository }}.git
             cd $(basename ${{ github.repository }})
             \`\`\`
          2. Navigate to the scripts directory: \`cd scripts/zero-to-hero\`
          3. Run the setup scripts in order:
             \`\`\`bash
             ./setup-rust.sh
             ./install-chain-spec-builder.sh  
             ./install-omni-node.sh
             ./generate-chain-spec.sh
             ./start-node.sh
             \`\`\`
          
          #### Option 2: Download from release
          1. Download and extract \`parachain-zero-to-hero-scripts.tar.gz\` from this release
          2. Run the setup scripts in order (same commands as above)
          
          Your parachain node will be running at \`http://localhost:9944\`
          
          ### ğŸ”— Useful Links
          - [Setup Scripts Documentation](https://github.com/${{ github.repository }}/tree/$SCRIPTS_COMMIT_SHA/scripts/zero-to-hero/README.md)
          - [Scripts Directory](https://github.com/${{ github.repository }}/tree/$SCRIPTS_COMMIT_SHA/scripts/zero-to-hero)
          - [Parachain Source Repository](${{ env.PARACHAIN_REPO }})
          - [Polkadot Documentation](https://docs.polkadot.network/)
          - [Scripts Commit](${{ github.server_url }}/${{ github.repository }}/commit/$SCRIPTS_COMMIT_SHA)
          
          ---
          
          **Full Changelog**: ${{ github.server_url }}/${{ github.repository }}/compare/$PREVIOUS_TAG...v$NEW_VERSION
          EOF
          
          echo "changelog-file=$CHANGELOG_FILE" >> $GITHUB_OUTPUT
          
          echo "$(date -Iseconds) âœ… Changelog generated:"
          echo "ğŸ“„ File: $CHANGELOG_FILE"
          echo "ğŸ“Š Size: $(du -h $CHANGELOG_FILE | cut -f1)"

      - name: Create and push tag
        id: create-tag
        run: |
          echo "$(date -Iseconds) ğŸ·ï¸ Creating and pushing tag..."
          
          NEW_VERSION="${{ steps.version-bump.outputs.new-version }}"
          TAG_NAME="v$NEW_VERSION"
          CHANGED_VERSIONS="${{ needs.check-version-changes.outputs.changed-versions }}"
          SCRIPTS_COMMIT_SHA="${{ needs.generate-scripts.outputs.commit-sha }}"
          
          # Configure git
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          
          # FIXED: Create annotated tag on current HEAD (which is the scripts commit)
          git tag -a "$TAG_NAME" -m "Release $TAG_NAME

          Automated release with parachain setup scripts.
          
          Version changes: $CHANGED_VERSIONS
          
          Component versions:
          - Rust: ${{ needs.generate-scripts.outputs.rust-version }}
          - Chain Spec Builder: ${{ needs.generate-scripts.outputs.chain-spec-builder-version }}  
          - Omni Node: ${{ needs.generate-scripts.outputs.omni-node-version }}
          
          Scripts included in release:
          - setup-rust.sh
          - install-chain-spec-builder.sh
          - install-omni-node.sh
          - generate-chain-spec.sh
          - start-node.sh
          - README.md
          
          Generated: $(date -u +"%Y-%m-%d %H:%M:%S UTC")
          Scripts Commit: $SCRIPTS_COMMIT_SHA
          Branch: ${{ github.ref_name }}"
          
          # Push the tag
          git push origin "$TAG_NAME"
          
          echo "tag=$TAG_NAME" >> $GITHUB_OUTPUT
          
          echo "$(date -Iseconds) âœ… Tag created and pushed:"
          echo "ğŸ·ï¸ Tag: $TAG_NAME"
          echo "ğŸ“ Tagged commit: $(git rev-parse HEAD) (includes scripts)"
          echo "ğŸ”„ Changes: $CHANGED_VERSIONS"

      - name: Create scripts archive for release
        run: |
          echo "$(date -Iseconds) ğŸ“¦ Creating scripts archive for release..."
          
          # Verify scripts exist
          if [ ! -d "scripts/zero-to-hero" ]; then
            echo "âŒ Scripts directory not found!"
            exit 1
          fi
          
          # Create the archive
          tar -czf parachain-zero-to-hero-scripts.tar.gz scripts/zero-to-hero/
          
          echo "âœ… Archive created: parachain-zero-to-hero-scripts.tar.gz"
          echo "ğŸ“Š Archive size: $(du -h parachain-zero-to-hero-scripts.tar.gz | cut -f1)"
          
          # Verify archive contents
          echo "ğŸ“‹ Archive contents:"
          tar -tzf parachain-zero-to-hero-scripts.tar.gz

      - name: Create GitHub Release
        id: create-release
        uses: softprops/action-gh-release@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          tag_name: ${{ steps.create-tag.outputs.tag }}
          name: "Parachain Setup Scripts ${{ steps.create-tag.outputs.tag }}"
          body_path: ${{ steps.changelog.outputs.changelog-file }}
          draft: false
          prerelease: ${{ contains(steps.version-bump.outputs.new-version, '-') }}
          files: |
            parachain-zero-to-hero-scripts.tar.gz
            scripts/zero-to-hero/setup-rust.sh
            scripts/zero-to-hero/install-chain-spec-builder.sh
            scripts/zero-to-hero/install-omni-node.sh
            scripts/zero-to-hero/generate-chain-spec.sh
            scripts/zero-to-hero/start-node.sh
            scripts/zero-to-hero/README.md

      - name: Release summary
        run: |
          echo "$(date -Iseconds) ğŸ‰ Release created successfully!"
          echo ""
          echo "ğŸ“‹ Release Details:"
          echo "  ğŸ·ï¸ Tag: ${{ steps.create-tag.outputs.tag }}"
          echo "  ğŸ“ Type: ${{ steps.version-bump.outputs.bump-type }}"
          echo "  ğŸ”— URL: ${{ steps.create-release.outputs.html_url }}"
          echo "  ğŸ“¦ Archive: parachain-zero-to-hero-scripts.tar.gz"
          echo "  ğŸ”„ Changes: ${{ needs.check-version-changes.outputs.changed-versions }}"
          echo "  ğŸ“ Tagged Commit: ${{ needs.generate-scripts.outputs.commit-sha }}"
          echo ""
          echo "ğŸ“¦ Component Versions:"
          echo "  ğŸ¦€ Rust: ${{ needs.generate-scripts.outputs.rust-version }}"
          echo "  ğŸ”§ Chain Spec Builder: ${{ needs.generate-scripts.outputs.chain-spec-builder-version }}"
          echo "  ğŸš€ Omni Node: ${{ needs.generate-scripts.outputs.omni-node-version }}"
          echo ""
          echo "ğŸ¯ Release includes:"
          echo "  - All setup scripts committed to repository"
          echo "  - Downloadable scripts archive (tar.gz)"
          echo "  - Individual script files"
          echo "  - Comprehensive documentation"
          echo ""
          echo "âœ… Scripts are available:"
          echo "  - In repository: scripts/zero-to-hero/"
          echo "  - In release: ${{ steps.create-release.outputs.html_url }}"
          echo "  - Tagged at commit: ${{ needs.generate-scripts.outputs.commit-sha }}"

  # Debug job to understand release conditions
  debug-release-conditions:
    name: Debug Release Conditions
    runs-on: ubuntu-latest
    needs: [check-version-changes, build-parachain, generate-scripts]
    if: always() && needs.check-version-changes.outputs.has-changes == 'true'
    steps:
      - name: Show release conditions
        run: |
          echo "ğŸ” Release condition check:"
          echo "  - has-changes: ${{ needs.check-version-changes.outputs.has-changes }}"
          echo "  - build-parachain result: ${{ needs.build-parachain.result }}"
          echo "  - generate-scripts result: ${{ needs.generate-scripts.result }}"
          echo "  - scripts-committed: ${{ needs.generate-scripts.outputs.scripts-committed }}"
          echo "  - event name: ${{ github.event_name }}"
          echo "  - ref: ${{ github.ref }}"
          echo "  - ref name: ${{ github.ref_name }}"
          echo "  - manual release input: ${{ github.event.inputs.create_release }}"
          echo ""
          echo "Release conditions evaluation:"
          echo "  - Auto release (push to master/dev): $([ "${{ github.event_name }}" = "push" ] && ([ "${{ github.ref }}" = "refs/heads/master" ] || [ "${{ github.ref }}" = "refs/heads/dev" ]) && echo "YES" || echo "NO")"
          echo "  - Manual release requested: $([ "${{ github.event.inputs.create_release }}" = "true" ] && echo "YES" || echo "NO")"
          echo "  - Scripts generation successful: $([ "${{ needs.generate-scripts.result }}" = "success" ] && echo "YES" || echo "NO")"
          echo "  - Scripts committed: $([ "${{ needs.generate-scripts.outputs.scripts-committed }}" = "true" ] && echo "YES" || echo "NO")"
          echo ""
          echo "ğŸ”„ Will run create-release job: $([ "${{ needs.generate-scripts.outputs.scripts-committed }}" = "true" ] && ([ "${{ github.event_name }}" = "push" ] && ([ "${{ github.ref }}" = "refs/heads/master" ] || [ "${{ github.ref }}" = "refs/heads/dev" ]) || [ "${{ github.event.inputs.create_release }}" = "true" ]) && echo "YES" || echo "NO")"

  # Summary job that runs regardless of whether scripts were generated
  workflow-summary:
    name: Workflow Summary
    runs-on: ubuntu-latest
    needs: [check-version-changes, build-parachain, generate-scripts, create-release]
    if: always()
    steps:
      - name: Display workflow summary
        run: |
          echo "$(date -Iseconds) ğŸ“‹ Zero to Hero Workflow Summary"
          echo ""
          echo "ğŸ” Version Change Check:"
          
          if [ "${{ needs.check-version-changes.outputs.has-changes }}" = "true" ]; then
            echo "  âœ… Changes detected: ${{ needs.check-version-changes.outputs.changed-versions }}"
            echo "  ğŸš€ Scripts generation was triggered"
            echo ""
            
            # Build status
            echo "ğŸ—ï¸ Parachain Build:"
            case "${{ needs.build-parachain.result }}" in
              "success") echo "  âœ… Build completed successfully" ;;
              "failure") echo "  âŒ Build failed" ;;
              "cancelled") echo "  âš ï¸ Build was cancelled" ;;
              "skipped") echo "  â­ï¸ Build was skipped" ;;
              *) echo "  â³ Build status: ${{ needs.build-parachain.result }}" ;;
            esac
            echo ""
            
            # Script generation status
            echo "ğŸ“œ Script Generation:"
            case "${{ needs.generate-scripts.result }}" in
              "success") 
                echo "  âœ… Scripts generated successfully"
                echo "  ğŸ’¾ Scripts committed: ${{ needs.generate-scripts.outputs.scripts-committed }}"
                if [ "${{ needs.generate-scripts.outputs.scripts-committed }}" = "true" ]; then
                  echo "  ğŸ“ Commit: ${{ needs.generate-scripts.outputs.commit-sha }}"
                fi
                ;;
              "failure") echo "  âŒ Scripts generation failed" ;;
              "cancelled") echo "  âš ï¸ Scripts generation was cancelled" ;;
              *) echo "  â³ Scripts generation status: ${{ needs.generate-scripts.result }}" ;;
            esac
            echo ""
            
            # Release status
            echo "ğŸš€ Release Creation:"
            case "${{ needs.create-release.result }}" in
              "success") 
                echo "  âœ… Release created successfully"
                echo "  ğŸ·ï¸ Tag: ${{ needs.create-release.outputs.release-tag }}"
                echo "  ğŸ”— URL: ${{ needs.create-release.outputs.release-url }}"
                echo "  ğŸ“ Scripts included from commit: ${{ needs.generate-scripts.outputs.commit-sha }}"
                ;;
              "failure") echo "  âŒ Release creation failed" ;;
              "cancelled") echo "  âš ï¸ Release creation was cancelled" ;;
              "skipped") 
                echo "  â­ï¸ Release creation was skipped"
                echo "  ğŸ’¡ Reasons for skipping:"
                if [ "${{ needs.generate-scripts.outputs.scripts-committed }}" != "true" ]; then
                  echo "    - Scripts were not committed to repository"
                fi
                if [ "${{ github.event_name }}" != "push" ] && [ "${{ github.event.inputs.create_release }}" != "true" ]; then
                  echo "    - Not a push event and manual release not requested"
                fi
                if [ "${{ github.ref }}" != "refs/heads/master" ] && [ "${{ github.ref }}" != "refs/heads/dev" ] && [ "${{ github.event.inputs.create_release }}" != "true" ]; then
                  echo "    - Not on master/dev branch and manual release not requested"
                fi
                ;;
              *) echo "  â³ Release status: ${{ needs.create-release.result }}" ;;
            esac
            echo ""
            
            # Version information
            if [ "${{ needs.generate-scripts.result }}" = "success" ]; then
              echo "ğŸ“¦ Component Versions:"
              echo "  ğŸ¦€ Rust: ${{ needs.generate-scripts.outputs.rust-version }}"
              echo "  ğŸ”§ Chain Spec Builder: ${{ needs.generate-scripts.outputs.chain-spec-builder-version }}"
              echo "  ğŸš€ Omni Node: ${{ needs.generate-scripts.outputs.omni-node-version }}"
              echo ""
            fi
            
          else
            echo "  â„¹ï¸ No zero_to_hero version changes detected"
            echo "  â­ï¸ Scripts generation was skipped"
            echo ""
            echo "ğŸ’¡ To trigger script generation:"
            echo "  - Modify versions in the zero_to_hero section of .github/versions.yml"
            echo "  - Or run this workflow manually via workflow_dispatch"
            echo "  - Or use the 'force_generation' input when running manually"
          fi
          
          echo ""
          echo "ğŸ”§ Workflow Information:"
          echo "  - Trigger: ${{ github.event_name }}"
          echo "  - Branch: ${{ github.ref_name }}"
          echo "  - Commit: ${{ github.sha }}"
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            echo "  - Manual release requested: ${{ github.event.inputs.create_release }}"
            echo "  - Force generation: ${{ github.event.inputs.force_generation }}"
          fi
          
          echo ""
          echo "ğŸ“ Next Steps:"
          if [ "${{ needs.generate-scripts.outputs.scripts-committed }}" = "true" ]; then
            echo "  âœ… Scripts are available in the repository at scripts/zero-to-hero/"
            echo "  ğŸ“– See scripts/zero-to-hero/README.md for usage instructions"
            echo "  ğŸ”— Scripts commit: ${{ needs.generate-scripts.outputs.commit-sha }}"
          fi
          if [ "${{ needs.create-release.result }}" = "success" ]; then
            echo "  âœ… Scripts are also available as release assets"
            echo "  ğŸ“¥ Download from: ${{ needs.create-release.outputs.release-url }}"
            echo "  ğŸ·ï¸ Release tag: ${{ needs.create-release.outputs.release-tag }}"
          fi
          if [ "${{ needs.check-version-changes.outputs.has-changes }}" != "true" ]; then
            echo "  ğŸ’¡ No action needed - versions are up to date"
          fi