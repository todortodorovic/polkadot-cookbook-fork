name: Create Zero to Hero Release
description: "Test Zero to Hero code, generate Zero to Hero scripts, and publish a release"

run-name: "Zero to Hero"

env:
  PARACHAIN_REPO: "https://github.com/polkadot-developers/polkadot-docs-tests/"
  PARACHAIN_BRANCH: ${{ github.ref_name }}
  PARA_ID: "1000"
  RELAY_CHAIN: "paseo"

on:
  workflow_dispatch:
    inputs:
      create_release:
        description: 'Create a release after generating scripts'
        required: false
        default: false
        type: boolean
      force_generation:
        description: 'Force script generation even if no version changes detected'
        required: false
        default: false
        type: boolean
  push:
    branches: [ master, dev ]
    paths:
      - 'versions.yml'

jobs:
  # Check if zero_to_hero versions have changed
  check-version-changes:
    name: Check Version Changes
    runs-on: ubuntu-latest
    outputs:
      has-changes: ${{ steps.check-changes.outputs.has-changes }}
      changed-versions: ${{ steps.check-changes.outputs.changed-versions }}
    steps:
      - name: Checkout current commit
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Install yq for YAML parsing
        run: |
          sudo wget -qO /usr/local/bin/yq https://github.com/mikefarah/yq/releases/latest/download/yq_linux_amd64
          sudo chmod +x /usr/local/bin/yq

      - name: Check for zero_to_hero version changes
        id: check-changes
        run: |
          echo "$(date -Iseconds) ğŸ” Checking for zero_to_hero version changes..."
          
          DEPS_FILE="versions.yml"
          TUTORIAL="zero_to_hero"
          HAS_CHANGES="false"
          CHANGED_VERSIONS=""
          
          # Validate that config file exists
          if [ ! -f "$DEPS_FILE" ]; then
            echo "âŒ Dependencies file not found: $DEPS_FILE"
            exit 1
          fi
          
          # Function to get version (tutorial-specific first, then global)
          get_version() {
            local dep="$1"
            local version
            
            # Try tutorial-specific version first
            version=$(yq eval ".${TUTORIAL}.${dep}" "$DEPS_FILE" 2>/dev/null)
            if [ "$version" = "null" ] || [ -z "$version" ]; then
              # Fallback to global version
              version=$(yq eval ".versions.${dep}" "$DEPS_FILE" 2>/dev/null)
            fi
            
            echo "$version"
          }
          
          # Get current versions
          CURRENT_RUST=$(get_version "rust")
          CURRENT_CHAIN_SPEC=$(get_version "chain_spec_builder") 
          CURRENT_OMNI_NODE=$(get_version "polkadot_omni_node")
          
          echo "ğŸ“‹ Current versions:"
          echo "  - rust: $CURRENT_RUST"
          echo "  - chain_spec_builder: $CURRENT_CHAIN_SPEC"
          echo "  - polkadot_omni_node: $CURRENT_OMNI_NODE"
          
          # Check for manual force generation
          if [ "${{ github.event.inputs.force_generation }}" = "true" ]; then
            echo "ğŸ”„ Force generation enabled - proceeding with script generation"
            HAS_CHANGES="true"
            CHANGED_VERSIONS="forced generation"
          # For workflow_dispatch, always proceed unless explicitly forced
          elif [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            echo "ğŸ”„ Manual trigger detected - proceeding with script generation"
            HAS_CHANGES="true"
            CHANGED_VERSIONS="manual trigger"
          else
            # For push/PR events, check what changed
            if [ "${{ github.event_name }}" = "pull_request" ]; then
              BASE_SHA="${{ github.event.pull_request.base.sha }}"
            else
              # For push events, compare with previous commit
              BASE_SHA="${{ github.event.before }}"
            fi
            
            echo "ğŸ” Comparing with base commit: $BASE_SHA"
            
            # Check if we have a valid base SHA and it exists
            if [ "$BASE_SHA" != "0000000000000000000000000000000000000000" ] && git cat-file -e "$BASE_SHA" 2>/dev/null; then
              # Get previous versions if the file existed
              if git cat-file -e "$BASE_SHA:$DEPS_FILE" 2>/dev/null; then
                echo "ğŸ“‹ Getting previous versions from $BASE_SHA..."
                
                # Create temporary file with previous versions
                git show "$BASE_SHA:$DEPS_FILE" > previous_versions.yml
                
                # Function to get version from previous file
                get_previous_version() {
                  local dep="$1"
                  local version
                  
                  # Try tutorial-specific version first
                  version=$(yq eval ".${TUTORIAL}.${dep}" previous_versions.yml 2>/dev/null)
                  if [ "$version" = "null" ] || [ -z "$version" ]; then
                    # Fallback to global version
                    version=$(yq eval ".versions.${dep}" previous_versions.yml 2>/dev/null)
                  fi
                  
                  echo "$version"
                }
                
                PREVIOUS_RUST=$(get_previous_version "rust")
                PREVIOUS_CHAIN_SPEC=$(get_previous_version "chain_spec_builder")
                PREVIOUS_OMNI_NODE=$(get_previous_version "polkadot_omni_node")
                
                echo "ğŸ“‹ Previous versions:"
                echo "  - rust: $PREVIOUS_RUST"
                echo "  - chain_spec_builder: $PREVIOUS_CHAIN_SPEC"  
                echo "  - polkadot_omni_node: $PREVIOUS_OMNI_NODE"
                
                # Compare versions
                CHANGES_FOUND=""
                
                if [ "$CURRENT_RUST" != "$PREVIOUS_RUST" ]; then
                  echo "ğŸ”„ Rust version changed: $PREVIOUS_RUST â†’ $CURRENT_RUST"
                  CHANGES_FOUND="$CHANGES_FOUND rust($PREVIOUS_RUSTâ†’$CURRENT_RUST)"
                fi
                
                if [ "$CURRENT_CHAIN_SPEC" != "$PREVIOUS_CHAIN_SPEC" ]; then
                  echo "ğŸ”„ Chain spec builder version changed: $PREVIOUS_CHAIN_SPEC â†’ $CURRENT_CHAIN_SPEC"
                  CHANGES_FOUND="$CHANGES_FOUND chain_spec_builder($PREVIOUS_CHAIN_SPECâ†’$CURRENT_CHAIN_SPEC)"
                fi
                
                if [ "$CURRENT_OMNI_NODE" != "$PREVIOUS_OMNI_NODE" ]; then
                  echo "ğŸ”„ Omni node version changed: $PREVIOUS_OMNI_NODE â†’ $CURRENT_OMNI_NODE"
                  CHANGES_FOUND="$CHANGES_FOUND polkadot_omni_node($PREVIOUS_OMNI_NODEâ†’$CURRENT_OMNI_NODE)"
                fi
                
                if [ -n "$CHANGES_FOUND" ]; then
                  HAS_CHANGES="true"
                  CHANGED_VERSIONS="$CHANGES_FOUND"
                  echo "âœ… Zero to Hero version changes detected!"
                else
                  echo "â„¹ï¸ No zero_to_hero version changes detected"
                fi
                
                # Cleanup
                rm -f previous_versions.yml
              else
                echo "ğŸ“ Previous versions.yml not found - treating as new file"
                HAS_CHANGES="true"
                CHANGED_VERSIONS="new versions file"
              fi
            else
              echo "âš ï¸ Cannot compare versions (invalid or missing base commit) - proceeding with generation"
              HAS_CHANGES="true"
              CHANGED_VERSIONS="unable to compare"
            fi
          fi
          
          echo "has-changes=$HAS_CHANGES" >> $GITHUB_OUTPUT
          echo "changed-versions=$CHANGED_VERSIONS" >> $GITHUB_OUTPUT
          
          if [ "$HAS_CHANGES" = "true" ]; then
            echo "$(date -Iseconds) âœ… Proceeding with script generation"
            echo "ğŸ“‹ Changes detected: $CHANGED_VERSIONS"
          else
            echo "$(date -Iseconds) â­ï¸ Skipping script generation (no version changes)"
          fi

  # First, run the existing parachain build workflow
  build-parachain:
    name: Build Parachain
    needs: check-version-changes
    if: needs.check-version-changes.outputs.has-changes == 'true'
    uses: ./.github/workflows/build-kitchensink-parachain.yml
    secrets: inherit

  # Generate setup scripts after successful build
  generate-scripts:
    name: Generate Scripts for Zero to Hero tutorial
    runs-on: ubuntu-latest
    needs: [check-version-changes, build-parachain]
    if: always() && needs.check-version-changes.outputs.has-changes == 'true' && needs.build-parachain.result == 'success'
    outputs:
      rust-version: ${{ steps.resolve-versions.outputs.rust-version }}
      chain-spec-builder-version: ${{ steps.resolve-versions.outputs.chain-spec-builder-version }}
      omni-node-version: ${{ steps.resolve-versions.outputs.omni-node-version }}
      scripts-committed: ${{ steps.commit-scripts.outputs.scripts-committed }}
      commit-sha: ${{ steps.commit-scripts.outputs.commit-sha }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          # Fetch full history for proper git operations
          fetch-depth: 0
          # Use a token that can push to protected branches
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Read versions from versions.yml
        id: resolve-versions
        run: |
          # Install yq for YAML parsing
          sudo wget -qO /usr/local/bin/yq https://github.com/mikefarah/yq/releases/latest/download/yq_linux_amd64
          sudo chmod +x /usr/local/bin/yq
          
          DEPS_FILE="versions.yml"
          TUTORIAL="zero_to_hero"
          
          # Validate that config file exists
          if [ ! -f "$DEPS_FILE" ]; then
            echo "âŒ Dependencies file not found: $DEPS_FILE"
            exit 1
          fi
          
          # Function to get version (tutorial-specific first, then global)
          get_version() {
            local dep="$1"
            local version
            
            # Try tutorial-specific version first
            version=$(yq eval ".${TUTORIAL}.${dep}" "$DEPS_FILE" 2>/dev/null)
            if [ "$version" = "null" ] || [ -z "$version" ]; then
              # Fallback to global version
              version=$(yq eval ".versions.${dep}" "$DEPS_FILE" 2>/dev/null)
            fi
            
            echo "$version"
          }
          
          # Get versions from config file
          CHAIN_SPEC_VERSION=$(get_version "chain_spec_builder")
          OMNI_NODE_VERSION=$(get_version "polkadot_omni_node")
          RUST_VERSION=$(get_version "rust")
          
          # Validate all versions were resolved
          if [ -z "$CHAIN_SPEC_VERSION" ] || [ "$CHAIN_SPEC_VERSION" = "null" ]; then
            echo "âŒ chain-spec-builder version not resolved"
            exit 1
          fi
          
          if [ -z "$OMNI_NODE_VERSION" ] || [ "$OMNI_NODE_VERSION" = "null" ]; then
            echo "âŒ omni-node version not resolved"
            exit 1
          fi
          
          if [ -z "$RUST_VERSION" ] || [ "$RUST_VERSION" = "null" ]; then
            echo "âŒ rust version not resolved"
            exit 1
          fi
          
          echo "chain-spec-builder-version=$CHAIN_SPEC_VERSION" >> $GITHUB_OUTPUT
          echo "omni-node-version=$OMNI_NODE_VERSION" >> $GITHUB_OUTPUT
          echo "rust-version=$RUST_VERSION" >> $GITHUB_OUTPUT
          
          echo "$(date -Iseconds) ğŸ“‹ Resolved versions for scripts:"
          echo "  - chain-spec-builder: $CHAIN_SPEC_VERSION"
          echo "  - omni-node: $OMNI_NODE_VERSION" 
          echo "  - rust: $RUST_VERSION"
          echo "ğŸ”„ Triggered by: ${{ needs.check-version-changes.outputs.changed-versions }}"

      - name: Create tutorial scripts directory
        run: |
          echo "$(date -Iseconds) ğŸ“ Creating scripts directory..."
          mkdir -p tutorials/zero-to-hero/scripts
          echo "âœ… Tutorial scripts directory created at tutorials/zero-to-hero/scripts"

      - name: Generate Rust setup script
        run: |
          echo "$(date -Iseconds) ğŸ¦€ Generating Rust setup script..."
          cat > tutorials/zero-to-hero/scripts/setup-rust.sh << 'EOF'
          #!/bin/bash
          # Rust Setup Script
          # This script sets up Rust with the required version and components
          
          set -e
          
          RUST_VERSION="${{ steps.resolve-versions.outputs.rust-version }}"
          
          echo "ğŸ¦€ Setting up Rust ${{ steps.resolve-versions.outputs.rust-version }}..."
          echo "ğŸ“¦ Installing Rust toolchain and components..."
          
          # Set default Rust version
          rustup default ${{ steps.resolve-versions.outputs.rust-version }}
          
          # Add WASM target for the current platform
          rustup target add wasm32-unknown-unknown --toolchain ${{ steps.resolve-versions.outputs.rust-version }}
          
          # Add rust source for the current platform  
          rustup component add rust-src --toolchain ${{ steps.resolve-versions.outputs.rust-version }}
          
          echo "âœ… Rust setup completed successfully!"
          echo "ğŸ“‹ Installed components:"
          echo "  - Rust toolchain: ${{ steps.resolve-versions.outputs.rust-version }}"
          echo "  - WASM target: wasm32-unknown-unknown"
          echo "  - Rust source component"
          
          # Verify installation
          echo "ğŸ” Verifying installation..."
          rustup show
          EOF
          
          chmod +x tutorials/zero-to-hero/scripts/setup-rust.sh
          echo "âœ… Rust setup script created: tutorials/zero-to-hero/scripts/setup-rust.sh"

      - name: Generate chain-spec-builder setup script
        run: |
          echo "$(date -Iseconds) ğŸ”§ Generating chain-spec-builder setup script..."
          cat > tutorials/zero-to-hero/scripts/install-chain-spec-builder.sh << 'EOF'
          #!/bin/bash
          # Chain Spec Builder Installation Script
          # This script installs the staging-chain-spec-builder tool
          
          set -e
          
          CHAIN_SPEC_VERSION="${{ steps.resolve-versions.outputs.chain-spec-builder-version }}"
          
          echo "ğŸ”§ Installing staging-chain-spec-builder ${{ steps.resolve-versions.outputs.chain-spec-builder-version }}..."
          
          # Install chain-spec-builder with locked dependencies
          cargo install --locked staging-chain-spec-builder@${{ steps.resolve-versions.outputs.chain-spec-builder-version }}
          
          echo "âœ… Chain spec builder installation completed!"
          echo "ğŸ“‹ Installed version: ${{ steps.resolve-versions.outputs.chain-spec-builder-version }}"
          
          # Verify installation
          echo "ğŸ” Verifying installation..."
          chain-spec-builder --version
          EOF
          
          chmod +x tutorials/zero-to-hero/scripts/install-chain-spec-builder.sh
          echo "âœ… Chain spec builder script created: tutorials/zero-to-hero/scripts/install-chain-spec-builder.sh"

      - name: Generate omni-node setup script
        run: |
          echo "$(date -Iseconds) ğŸš€ Generating omni-node setup script..."
          cat > tutorials/zero-to-hero/scripts/install-omni-node.sh << 'EOF'
          #!/bin/bash
          # Omni Node Installation Script  
          # This script installs the polkadot-omni-node
          
          set -e
          
          OMNI_NODE_VERSION="${{ steps.resolve-versions.outputs.omni-node-version }}"
          
          echo "ğŸš€ Installing polkadot-omni-node ${{ steps.resolve-versions.outputs.omni-node-version }}..."
          
          # Install omni-node with locked dependencies
          cargo install --locked polkadot-omni-node@${{ steps.resolve-versions.outputs.omni-node-version }}
          
          echo "âœ… Omni node installation completed!"
          echo "ğŸ“‹ Installed version: ${{ steps.resolve-versions.outputs.omni-node-version }}"
          
          # Verify installation
          echo "ğŸ” Verifying installation..."
          polkadot-omni-node --version
          EOF
          
          chmod +x tutorials/zero-to-hero/scripts/install-omni-node.sh  
          echo "âœ… Omni node script created: tutorials/zero-to-hero/scripts/install-omni-node.sh"

      - name: Generate chain spec creation script
        run: |
          echo "$(date -Iseconds) â›“ï¸ Generating chain spec creation script..."
          cat > tutorials/zero-to-hero/scripts/generate-chain-spec.sh << 'EOF'
          #!/bin/bash
          # Chain Specification Generation Script
          # This script generates a development chain specification for the parachain
          
          set -e
          
          PARA_ID="${{ env.PARA_ID }}"
          RELAY_CHAIN="${{ env.RELAY_CHAIN }}"
          RUNTIME_PATH="./target/release/wbuild/parachain-template-runtime/parachain_template_runtime.compact.compressed.wasm"
          
          echo "â›“ï¸ Generating chain specification..."
          echo "ğŸ“‹ Configuration:"
          echo "  - Para ID: ${{ env.PARA_ID }}"
          echo "  - Relay Chain: ${{ env.RELAY_CHAIN }}"
          echo "  - Runtime: ./target/release/wbuild/parachain-template-runtime/parachain_template_runtime.compact.compressed.wasm"
          
          # Check if runtime exists
          if [ ! -f "./target/release/wbuild/parachain-template-runtime/parachain_template_runtime.compact.compressed.wasm" ]; then
            echo "âŒ Runtime WASM file not found: ./target/release/wbuild/parachain-template-runtime/parachain_template_runtime.compact.compressed.wasm"
            echo "ğŸ’¡ Make sure you have built the parachain runtime first"
            echo "ğŸ’¡ Try running: cargo build --release"
            exit 1
          fi
          
          # Generate chain specification
          chain-spec-builder create \
            -t development \
            --relay-chain ${{ env.RELAY_CHAIN }} \
            --para-id ${{ env.PARA_ID }} \
            --runtime ./target/release/wbuild/parachain-template-runtime/parachain_template_runtime.compact.compressed.wasm \
            named-preset development
          
          # Verify chain spec was created
          if [ ! -f "chain_spec.json" ]; then
            echo "âŒ Chain specification generation failed"
            exit 1
          fi
          
          echo "âœ… Chain specification generated successfully!"
          echo "ğŸ“„ Output file: chain_spec.json"
          echo "ğŸ“Š File size: $(du -h chain_spec.json | cut -f1)"
          
          # Validate JSON
          if command -v jq >/dev/null 2>&1; then
            echo "ğŸ” Validating JSON structure..."
            if jq empty chain_spec.json; then
              echo "âœ… Chain specification is valid JSON"
              
              # Extract key information
              CHAIN_NAME=$(jq -r '.name // "unknown"' chain_spec.json)
              echo "ğŸ“‹ Chain Name: $CHAIN_NAME"
            else
              echo "âš ï¸ Chain specification may have JSON formatting issues"
            fi
          fi
          EOF
          
          chmod +x tutorials/zero-to-hero/scripts/generate-chain-spec.sh
          echo "âœ… Chain spec generation script created: tutorials/zero-to-hero/scripts/generate-chain-spec.sh"

      - name: Generate node startup script
        run: |
          echo "$(date -Iseconds) ğŸ–¥ï¸ Generating node startup script..."
          cat > tutorials/zero-to-hero/scripts/start-node.sh << 'EOF'
          #!/bin/bash
          # Parachain Node Startup Script
          # This script starts the parachain node in development mode
          
          set -e
          
          CHAIN_SPEC="./chain_spec.json"
          
          echo "ğŸ–¥ï¸ Starting parachain node..."
          echo "ğŸ“‹ Configuration:"
          echo "  - Chain spec: $CHAIN_SPEC"
          echo "  - Mode: Development"
          echo "  - RPC: All CORS enabled, unsafe methods allowed"
          
          # Check if chain spec exists
          if [ ! -f "$CHAIN_SPEC" ]; then
            echo "âŒ Chain specification not found: $CHAIN_SPEC"
            echo "ğŸ’¡ Generate it first by running: ./tutorials/zero-to-hero/scripts/generate-chain-spec.sh"
            exit 1
          fi
          
          echo "ğŸš€ Starting polkadot-omni-node..."
          echo "ğŸ“¡ RPC will be available at: http://localhost:9944"
          echo "ğŸ” Press Ctrl+C to stop the node"
          echo ""
          
          # Start the node
          polkadot-omni-node \
            --chain $CHAIN_SPEC \
            --dev \
            --rpc-cors all \
            --rpc-methods unsafe
          EOF
          
          chmod +x tutorials/zero-to-hero/scripts/start-node.sh
          echo "âœ… Node startup script created: tutorials/zero-to-hero/scripts/start-node.sh"

      - name: Generate setup instructions
        run: |
          echo "$(date -Iseconds) ğŸ“– Generating setup instructions..."
          cat > tutorials/zero-to-hero/scripts/README.md << 'EOF'
          # Zero to Hero Scripts
          
          This directory contains scripts to set up and run a local parachain development environment.
          
          ## Generated Configuration
          
          These scripts were generated automatically with the following versions:
          - **Rust**: `${{ steps.resolve-versions.outputs.rust-version }}`
          - **Chain Spec Builder**: `${{ steps.resolve-versions.outputs.chain-spec-builder-version }}`
          - **Omni Node**: `${{ steps.resolve-versions.outputs.omni-node-version }}`
          - **Para ID**: `${{ env.PARA_ID }}`
          - **Relay Chain**: `${{ env.RELAY_CHAIN }}`
          
          ## Repository Information
          
          - **Source**: `${{ env.PARACHAIN_REPO }}`
          - **Branch**: `${{ env.PARACHAIN_BRANCH }}`
          - **Workflow**: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}
          - **Commit**: ${{ github.sha }}
          EOF
          
          echo "âœ… Setup instructions created: tutorials/zero-to-hero/scripts/README.md"

      - name: Validate generated scripts
        run: |
          echo "$(date -Iseconds) ğŸ” Validating generated scripts..."
          
          # Check that all scripts exist and are executable
          SCRIPTS=(
            "setup-rust.sh"
            "install-chain-spec-builder.sh" 
            "install-omni-node.sh"
            "generate-chain-spec.sh"
            "start-node.sh"
          )
          
          for script in "${SCRIPTS[@]}"; do
            SCRIPT_PATH="tutorials/zero-to-hero/scripts/$script"
            if [ -f "$SCRIPT_PATH" ] && [ -x "$SCRIPT_PATH" ]; then
              echo "âœ… $script - exists and executable"
              echo "   ğŸ“Š Size: $(du -h "$SCRIPT_PATH" | cut -f1)"
            else
              echo "âŒ $script - missing or not executable"
              exit 1
            fi
          done
          
          # Validate README exists
          if [ -f "tutorials/zero-to-hero/scripts/README.md" ]; then
            echo "âœ… README.md - exists"
            echo "   ğŸ“Š Size: $(du -h tutorials/zero-to-hero/scripts/README.md | cut -f1)"
          else
            echo "âŒ README.md - missing"
            exit 1
          fi
          
          echo "$(date -Iseconds) âœ… All scripts validated successfully"

      - name: Commit generated scripts to repository
        id: commit-scripts
        run: |
          echo "$(date -Iseconds) ğŸ’¾ Committing generated scripts to repository..."
          
          # Configure git with bot credentials
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          
          # Add the tutorial scripts directory
          git add tutorials/zero-to-hero/scripts/
          
          # Check if there are changes to commit
          if git diff --cached --quiet; then
            echo "â„¹ï¸ No changes to commit - scripts are up to date"
            echo "scripts-committed=false" >> $GITHUB_OUTPUT
            echo "commit-sha=$(git rev-parse HEAD)" >> $GITHUB_OUTPUT
          else
            # Create a comprehensive commit message
            COMMIT_MSG="ğŸ¤– Update zero-to-hero setup scripts

          Version changes: ${{ needs.check-version-changes.outputs.changed-versions }}
          
          Updated component versions:
          - Rust: ${{ steps.resolve-versions.outputs.rust-version }}
          - Chain Spec Builder: ${{ steps.resolve-versions.outputs.chain-spec-builder-version }}
          - Omni Node: ${{ steps.resolve-versions.outputs.omni-node-version }}
          
          Generated: $(date -u +'%Y-%m-%d %H:%M:%S UTC')
          Workflow: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}
          
          Co-authored-by: github-actions[bot] <github-actions[bot]@users.noreply.github.com>"
            
            # Commit the changes
            git commit -m "$COMMIT_MSG"
            
            # Get the commit SHA after committing
            COMMIT_SHA=$(git rev-parse HEAD)
            
            # Push the changes
            echo "ğŸ“¤ Pushing changes to ${{ github.ref_name }}..."
            git push origin ${{ github.ref_name }}
            
            echo "âœ… Scripts committed and pushed to repository"
            echo "ğŸ“‹ Commit: $COMMIT_SHA"
            echo "ğŸ”— View: ${{ github.server_url }}/${{ github.repository }}/commit/$COMMIT_SHA"
            
            echo "scripts-committed=true" >> $GITHUB_OUTPUT
            echo "commit-sha=$COMMIT_SHA" >> $GITHUB_OUTPUT
          fi

  create-release:
    name: Create Release with Scripts
    runs-on: ubuntu-latest
    needs: [check-version-changes, build-parachain, generate-scripts]
    if: |
      always() && 
      needs.check-version-changes.outputs.has-changes == 'true' && 
      needs.generate-scripts.result == 'success' &&
      needs.generate-scripts.outputs.scripts-committed == 'true' &&
      (
        (github.event_name == 'push' && (github.ref == 'refs/heads/master' || github.ref == 'refs/heads/dev')) ||
        github.event.inputs.create_release == 'true'
      )
    permissions:
      contents: write
      actions: read
      pull-requests: read
    outputs:
      release-tag: ${{ steps.create-tag.outputs.tag }}
      release-url: ${{ steps.create-release.outputs.html_url }}
    steps:
      - name: Checkout at scripts commit
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}
          ref: ${{ needs.generate-scripts.outputs.commit-sha }}

      - name: Verify scripts are present
        run: |
          echo "$(date -Iseconds) ğŸ” Verifying scripts are present..."
          
          SCRIPTS_COMMIT_SHA="${{ needs.generate-scripts.outputs.commit-sha }}"
          CURRENT_SHA=$(git rev-parse HEAD)
          
          echo "ğŸ“‹ Expected commit: $SCRIPTS_COMMIT_SHA"
          echo "ğŸ“‹ Current commit: $CURRENT_SHA"
          
          if [ "$CURRENT_SHA" != "$SCRIPTS_COMMIT_SHA" ]; then
            echo "âŒ Not at expected commit! Fetching latest..."
            git fetch origin
            git checkout $SCRIPTS_COMMIT_SHA
            CURRENT_SHA=$(git rev-parse HEAD)
            echo "ğŸ“‹ Updated to: $CURRENT_SHA"
          fi
          
          # Verify tutorial scripts directory exists
          if [ -d "tutorials/zero-to-hero/scripts" ]; then
            echo "âœ… Scripts directory found"
            echo "ğŸ“‹ Scripts available:"
            ls -la tutorials/zero-to-hero/scripts/
          else
            echo "âŒ Scripts directory not found at commit $CURRENT_SHA!"
            echo "ğŸ” Repository contents:"
            ls -la
            exit 1
          fi

      - name: Determine version bump
        id: version-bump
        run: |
          echo "$(date -Iseconds) ğŸ” Determining version bump..."
          
          # Get the latest tag, default to v0.0.0 if no tags exist
          LATEST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "v0.0.0")
          echo "ğŸ“‹ Latest tag: $LATEST_TAG"
          
          # Extract version components (remove 'v' prefix)
          VERSION=${LATEST_TAG#v}
          IFS='.' read -ra VERSION_PARTS <<< "$VERSION"
          MAJOR=${VERSION_PARTS[0]:-0}
          MINOR=${VERSION_PARTS[1]:-0} 
          PATCH=${VERSION_PARTS[2]:-0}
          
          echo "ğŸ“‹ Current version: $MAJOR.$MINOR.$PATCH"
          
          # Analyze commits since last tag to determine bump type
          if [ "$LATEST_TAG" = "v0.0.0" ]; then
            COMMITS_SINCE=""
          else
            COMMITS_SINCE=$(git log $LATEST_TAG..HEAD --oneline)
          fi
          
          # Determine bump type based on commit messages and branch
          BUMP_TYPE="patch"  # Default to patch
          
          # Check for breaking changes (major bump)
          if echo "$COMMITS_SINCE" | grep -i -E "(breaking|major|BREAKING CHANGE)" > /dev/null; then
            BUMP_TYPE="major"
          # Check for new features (minor bump)
          elif echo "$COMMITS_SINCE" | grep -i -E "(feat|feature|add|new)" > /dev/null; then
            BUMP_TYPE="minor"
          # Check if we're on dev branch (pre-release)
          elif [ "${{ github.ref }}" = "refs/heads/dev" ]; then
            BUMP_TYPE="prerelease"
          fi
          
          # Apply version bump
          case $BUMP_TYPE in
            major)
              MAJOR=$((MAJOR + 1))
              MINOR=0
              PATCH=0
              ;;
            minor)
              MINOR=$((MINOR + 1))
              PATCH=0
              ;;
            patch)
              PATCH=$((PATCH + 1))
              ;;
            prerelease)
              # For pre-release, increment patch and add pre-release identifier
              PATCH=$((PATCH + 1))
              PRE_RELEASE="dev.$(date +%Y%m%d%H%M%S)"
              ;;
          esac
          
          # Construct new version
          if [ "$BUMP_TYPE" = "prerelease" ]; then
            NEW_VERSION="$MAJOR.$MINOR.$PATCH-$PRE_RELEASE"
          else
            NEW_VERSION="$MAJOR.$MINOR.$PATCH"
          fi
          
          echo "bump-type=$BUMP_TYPE" >> $GITHUB_OUTPUT
          echo "new-version=$NEW_VERSION" >> $GITHUB_OUTPUT
          echo "previous-tag=$LATEST_TAG" >> $GITHUB_OUTPUT
          
          echo "$(date -Iseconds) âœ… Version bump determined:"
          echo "  - Type: $BUMP_TYPE"
          echo "  - Previous: $LATEST_TAG"
          echo "  - New: v$NEW_VERSION"

      - name: Generate changelog
        id: changelog
        run: |
          echo "$(date -Iseconds) ğŸ“ Generating changelog..."
          
          NEW_VERSION="${{ steps.version-bump.outputs.new-version }}"
          PREVIOUS_TAG="${{ steps.version-bump.outputs.previous-tag }}"
          RUST_VERSION="${{ needs.generate-scripts.outputs.rust-version }}"
          CHAIN_SPEC_VERSION="${{ needs.generate-scripts.outputs.chain-spec-builder-version }}"
          OMNI_NODE_VERSION="${{ needs.generate-scripts.outputs.omni-node-version }}"
          CHANGED_VERSIONS="${{ needs.check-version-changes.outputs.changed-versions }}"
          SCRIPTS_COMMIT_SHA="${{ needs.generate-scripts.outputs.commit-sha }}"
          
          # Create changelog file
          CHANGELOG_FILE="RELEASE_CHANGELOG.md"
          
          cat > $CHANGELOG_FILE << EOF
          # Release v$NEW_VERSION
          
          Released: $(date -u +"%Y-%m-%d %H:%M:%S UTC")
          
          ### ğŸ“¦ Component Versions
          - **Rust Toolchain**: \`$RUST_VERSION\`
          - **Chain Spec Builder**: \`staging-chain-spec-builder@$CHAIN_SPEC_VERSION\`
          - **Omni Node**: \`polkadot-omni-node@$OMNI_NODE_VERSION\`
          - **Para ID**: \`${{ env.PARA_ID }}\`
          - **Relay Chain**: \`${{ env.RELAY_CHAIN }}\`
          
          ### ğŸ’¾ Repository Updates
          - Scripts automatically committed
          - Scripts Commit: [\`${SCRIPTS_COMMIT_SHA:0:7}\`](${{ github.server_url }}/${{ github.repository }}/commit/$SCRIPTS_COMMIT_SHA)
          
          EOF
          
          # Add commit history if available
          if [ "$PREVIOUS_TAG" != "v0.0.0" ]; then
            echo "### ğŸ“‹ Changes Since $PREVIOUS_TAG" >> $CHANGELOG_FILE
            echo "" >> $CHANGELOG_FILE
            
            # Get commits since last tag, format them nicely
            git log $PREVIOUS_TAG..HEAD --oneline --no-merges | head -20 | while read commit; do
              echo "- $commit" >> $CHANGELOG_FILE
            done
            
            echo "" >> $CHANGELOG_FILE
          fi
          
          # Add technical details
          cat >> $CHANGELOG_FILE << EOF
          ### ğŸ—ï¸ Build Information
          - **Workflow**: Version Change Detection â†’ Build Parachain â†’ Generate Scripts â†’ Commit to Repo â†’ Create Release
          - **Branch**: \`${{ github.ref_name }}\`
          - **Release Commit**: \`$SCRIPTS_COMMIT_SHA\`
          - **Parachain Source**: [\`${{ env.PARACHAIN_REPO }}\`](${{ env.PARACHAIN_REPO }})
          - **Version Changes**: $CHANGED_VERSIONS

          ---
          
          **Full Changelog**: ${{ github.server_url }}/${{ github.repository }}/compare/$PREVIOUS_TAG...v$NEW_VERSION
          EOF
          
          echo "changelog-file=$CHANGELOG_FILE" >> $GITHUB_OUTPUT
          
          echo "$(date -Iseconds) âœ… Changelog generated:"
          echo "ğŸ“„ File: $CHANGELOG_FILE"
          echo "ğŸ“Š Size: $(du -h $CHANGELOG_FILE | cut -f1)"

      - name: Create and push tag
        id: create-tag
        run: |
          echo "$(date -Iseconds) ğŸ·ï¸ Creating and pushing tag..."
          
          NEW_VERSION="${{ steps.version-bump.outputs.new-version }}"
          TAG_NAME="v$NEW_VERSION"
          CHANGED_VERSIONS="${{ needs.check-version-changes.outputs.changed-versions }}"
          SCRIPTS_COMMIT_SHA="${{ needs.generate-scripts.outputs.commit-sha }}"
          
          # Configure git
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          
          git tag -a "$TAG_NAME" -m "Release $TAG_NAME

          Automated release with parachain setup scripts.
          
          Version changes: $CHANGED_VERSIONS
          
          Component versions:
          - Rust: ${{ needs.generate-scripts.outputs.rust-version }}
          - Chain Spec Builder: ${{ needs.generate-scripts.outputs.chain-spec-builder-version }}  
          - Omni Node: ${{ needs.generate-scripts.outputs.omni-node-version }}
          
          Generated: $(date -u +"%Y-%m-%d %H:%M:%S UTC")
          Scripts Commit: $SCRIPTS_COMMIT_SHA
          Branch: ${{ github.ref_name }}"
          
          # Push the tag
          git push origin "$TAG_NAME"
          
          echo "tag=$TAG_NAME" >> $GITHUB_OUTPUT
          
          echo "$(date -Iseconds) âœ… Tag created and pushed:"
          echo "ğŸ·ï¸ Tag: $TAG_NAME"
          echo "ğŸ“ Tagged commit: $(git rev-parse HEAD) (includes scripts)"
          echo "ğŸ”„ Changes: $CHANGED_VERSIONS"

      - name: Create GitHub Release
        id: create-release
        uses: softprops/action-gh-release@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          tag_name: ${{ steps.create-tag.outputs.tag }}
          name: "Zero to Hero ${{ steps.create-tag.outputs.tag }}"
          body_path: ${{ steps.changelog.outputs.changelog-file }}
          draft: false
          prerelease: ${{ contains(steps.version-bump.outputs.new-version, '-') }}

      - name: Release summary
        run: |
          echo "$(date -Iseconds) ğŸ‰ Release created successfully!"
          echo ""
          echo "ğŸ“‹ Release Details:"
          echo "  ğŸ·ï¸ Tag: ${{ steps.create-tag.outputs.tag }}"
          echo "  ğŸ“ Type: ${{ steps.version-bump.outputs.bump-type }}"
          echo "  ğŸ”— URL: ${{ steps.create-release.outputs.html_url }}"
          echo "  ğŸ”„ Changes: ${{ needs.check-version-changes.outputs.changed-versions }}"
          echo "  ğŸ“ Tagged Commit: ${{ needs.generate-scripts.outputs.commit-sha }}"
          echo ""
          echo "ğŸ“¦ Component Versions:"
          echo "  ğŸ¦€ Rust: ${{ needs.generate-scripts.outputs.rust-version }}"
          echo "  ğŸ”§ Chain Spec Builder: ${{ needs.generate-scripts.outputs.chain-spec-builder-version }}"
          echo "  ğŸš€ Omni Node: ${{ needs.generate-scripts.outputs.omni-node-version }}"
          echo ""
          echo "ğŸ¯ Release includes:"
          echo "  - All scripts committed to repository"
          echo ""
          echo "âœ… Scripts are available:"
          echo "  - In repository: tutorials/zero-to-hero/scripts/"
          echo "  - In release: ${{ steps.create-release.outputs.html_url }}"
          echo "  - Tagged at commit: ${{ needs.generate-scripts.outputs.commit-sha }}"

  workflow-summary:
    name: Workflow Summary
    runs-on: ubuntu-latest
    needs: [check-version-changes, build-parachain, generate-scripts, create-release]
    if: always()
    steps:
      - name: Display workflow summary
        run: |
          echo "$(date -Iseconds) ğŸ“‹ Zero to Hero Workflow Summary"
          echo ""
          echo "ğŸ” Version Change Check:"
          
          if [ "${{ needs.check-version-changes.outputs.has-changes }}" = "true" ]; then
            echo "  âœ… Changes detected: ${{ needs.check-version-changes.outputs.changed-versions }}"
            echo "  ğŸš€ Scripts generation was triggered"
            echo ""
            
            # Build status
            echo "ğŸ—ï¸ Parachain Build:"
            case "${{ needs.build-parachain.result }}" in
              "success") echo "  âœ… Build completed successfully" ;;
              "failure") echo "  âŒ Build failed" ;;
              "cancelled") echo "  âš ï¸ Build was cancelled" ;;
              "skipped") echo "  â­ï¸ Build was skipped" ;;
              *) echo "  â³ Build status: ${{ needs.build-parachain.result }}" ;;
            esac
            echo ""
            
            # Script generation status
            echo "ğŸ“œ Script Generation:"
            case "${{ needs.generate-scripts.result }}" in
              "success") 
                echo "  âœ… Scripts generated successfully"
                echo "  ğŸ’¾ Scripts committed: ${{ needs.generate-scripts.outputs.scripts-committed }}"
                if [ "${{ needs.generate-scripts.outputs.scripts-committed }}" = "true" ]; then
                  echo "  ğŸ“ Commit: ${{ needs.generate-scripts.outputs.commit-sha }}"
                fi
                ;;
              "failure") echo "  âŒ Scripts generation failed" ;;
              "cancelled") echo "  âš ï¸ Scripts generation was cancelled" ;;
              *) echo "  â³ Scripts generation status: ${{ needs.generate-scripts.result }}" ;;
            esac
            echo ""
            
            # Release status
            echo "ğŸš€ Release Creation:"
            case "${{ needs.create-release.result }}" in
              "success") 
                echo "  âœ… Release created successfully"
                echo "  ğŸ·ï¸ Tag: ${{ needs.create-release.outputs.release-tag }}"
                echo "  ğŸ”— URL: ${{ needs.create-release.outputs.release-url }}"
                echo "  ğŸ“ Scripts included from commit: ${{ needs.generate-scripts.outputs.commit-sha }}"
                ;;
              "failure") echo "  âŒ Release creation failed" ;;
              "cancelled") echo "  âš ï¸ Release creation was cancelled" ;;
              "skipped") 
                echo "  â­ï¸ Release creation was skipped"
                echo "  ğŸ’¡ Reasons for skipping:"
                if [ "${{ needs.generate-scripts.outputs.scripts-committed }}" != "true" ]; then
                  echo "    - Scripts were not committed to repository"
                fi
                if [ "${{ github.event_name }}" != "push" ] && [ "${{ github.event.inputs.create_release }}" != "true" ]; then
                  echo "    - Not a push event and manual release not requested"
                fi
                if [ "${{ github.ref }}" != "refs/heads/master" ] && [ "${{ github.ref }}" != "refs/heads/dev" ] && [ "${{ github.event.inputs.create_release }}" != "true" ]; then
                  echo "    - Not on master/dev branch and manual release not requested"
                fi
                ;;
              *) echo "  â³ Release status: ${{ needs.create-release.result }}" ;;
            esac
            echo ""
            
            # Version information
            if [ "${{ needs.generate-scripts.result }}" = "success" ]; then
              echo "ğŸ“¦ Component Versions:"
              echo "  ğŸ¦€ Rust: ${{ needs.generate-scripts.outputs.rust-version }}"
              echo "  ğŸ”§ Chain Spec Builder: ${{ needs.generate-scripts.outputs.chain-spec-builder-version }}"
              echo "  ğŸš€ Omni Node: ${{ needs.generate-scripts.outputs.omni-node-version }}"
              echo ""
            fi
            
          else
            echo "  â„¹ï¸ No zero_to_hero version changes detected"
            echo "  â­ï¸ Scripts generation was skipped"
            echo ""
            echo "ğŸ’¡ To trigger script generation:"
            echo "  - Modify versions in the zero_to_hero section of versions.yml"
            echo "  - Or run this workflow manually via workflow_dispatch"
            echo "  - Or use the 'force_generation' input when running manually"
          fi
          
          echo ""
          echo "ğŸ”§ Workflow Information:"
          echo "  - Trigger: ${{ github.event_name }}"
          echo "  - Branch: ${{ github.ref_name }}"
          echo "  - Commit: ${{ github.sha }}"
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            echo "  - Manual release requested: ${{ github.event.inputs.create_release }}"
            echo "  - Force generation: ${{ github.event.inputs.force_generation }}"
          fi
          
          echo ""
          echo "ğŸ“ Next Steps:"
          if [ "${{ needs.generate-scripts.outputs.scripts-committed }}" = "true" ]; then
            echo "  âœ… Scripts are available in the repository at tutorials/zero-to-hero/scripts/"
            echo "  ğŸ“– See tutorials/zero-to-hero/scripts/README.md for usage instructions"
            echo "  ğŸ”— Scripts commit: ${{ needs.generate-scripts.outputs.commit-sha }}"
          fi
          if [ "${{ needs.check-version-changes.outputs.has-changes }}" != "true" ]; then
            echo "  ğŸ’¡ No action needed - versions are up to date"
          fi